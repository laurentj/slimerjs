<?xml version="1.0"  encoding="UTF-8" ?>
<bindings xmlns="http://www.mozilla.org/xbl"
        xmlns:xbl="http://www.mozilla.org/xbl"
        xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

    <!-- Binding around a browser that is used to load a web page -->
    <binding id="slimer_navigator">
        <content flex="1">
            <xul:browser anonid="mBrowser" flex="1"
                         type="content-targetable" autoscroll="true" disablesecurity="false"/>
        </content>
        <implementation>
            <constructor>
                <![CDATA[
                this.initProgressListener();
                this.initMessageManager();
                this.browser.messageManager.loadFrameScript('chrome://slimerjs/content/navigatorFrameScript.js', true);
                this._sendReadyEvent();
            ]]>
            </constructor>
            <destructor>
                this.resetBrowser();
            </destructor>

            <field name="browser" readonly="true">
                document.getAnonymousElementByAttribute(this, "anonid", "mBrowser");
            </field>

            <field name="onpageloaded">null</field>
            <field name="webPage">null</field>
            <field name="requestCounter">0</field>
            <method name="resetBrowser">
                <body>
                    this.onpageloaded = null;
                    this.browser.stop();
                    this.browser.removeProgressListener(this.mProgressListener);
                    this.webPage = null;
                    //this.browser.sessionHistory.PurgeHistory(1000);
                    this.browser.destroy();
                </body>
            </method>

            <method name="_sendReadyEvent">
                <body>
                    // before touching browser, we should wait that it is initialized,
                    // however we don't have a simple way to know when it is finished
                    // so let's trigger a timeout :-/ #uglyhack
                    var me = this;
                    window.setTimeout(function() {
                        var evt = document.createEvent("Event");
                        evt.initEvent("BrowserReady", true, false);
                        me.dispatchEvent(evt);
                    }, 100);
                </body>
            </method>

            <method name="initMessageManager">
                <body><![CDATA[
                var me = this;
                var mm = this.browser.messageManager;

                mm.addMessageListener("pageloaded", function(message){
                    let channel = me.browser.docShell.currentDocumentChannel
                    try {
                        channel = channel.QueryInterface(Components.interfaces.nsIHttpChannel);
                    }
                    catch(e){}
                    let success = "success";
                    if (channel) {
                        success = channel.requestSucceeded?"success":"fail";
                    }
                    if (me.webPage && me.webPage.onLoadFinished)
                        me.webPage.onLoadFinished(success)

                    if (me.onpageloaded)
                        me.onpageloaded(success);
                });
                ]]></body>
            </method>

            <method name="initProgressListener">
                <body>
                <![CDATA[
                    let ci = Components.interfaces;
                    let WPL = ci.nsIWebProgressListener;
                    let nav = this;
                    this.mProgressListener = {
                        _firstBlankLoad : true, // we should ignore the load of about:blank during initialization of <browser>
                        _mainPageLoading : false,
                        QueryInterface : function(aIID)
                        {
                          if (aIID.equals(WPL) ||
                              aIID.equals(ci.nsIWebProgressListener2) ||
                              aIID.equals(ci.nsISupportsWeakReference) ||
                              aIID.equals(ci.nsISupports))
                            return this;
                          throw Components.results.NS_NOINTERFACE;
                        },

                        onLocationChange : function(aWebProgress, aRequest, aLocation, aFlags)
                        {
                            if (this._firstBlankLoad)
                                return;

                            let failure = aFlags & WPL.LOCATION_CHANGE_ERROR_PAGE;
                            if (failure) {
                                if (nav.onpageloaded)
                                    nav.onpageloaded("fail");
                                return;
                            }
                            if (!nav.webPage)
                                return;
                            //let insidePage = aFlags & WPL.LOCATION_CHANGE_SAME_DOCUMENT;
                            if (nav.webPage.onUrlChanged)
                                nav.webPage.onUrlChanged(aLocation.spec);
                        },
                        onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
                        {
                            let uri = ''
                            if ((aRequest instanceof ci.nsIChannel || "URI" in aRequest)) {
                                if (this._firstBlankLoad) {
                                    if (aRequest.URI.spec == "about:blank" && aStateFlags & WPL.STATE_STOP && aStateFlags & WPL.STATE_IS_WINDOW)
                                        this._firstBlankLoad = false;
                                    return;
                                }
                                if (!nav.webPage)
                                    return;
                                uri = aRequest.URI.spec
                            }
                            else {
                                /*dump("onStateChange no URI");
                                if (aStateFlags & WPL.STATE_START)
                                    dump( " START");
                                if (aStateFlags & WPL.STATE_TRANSFERRING)
                                    dump( " TRANS");
                                if (aStateFlags & WPL.STATE_NEGOTIATING)
                                    dump( " NEGO");
                                if (aStateFlags & WPL.STATE_STOP)
                                    dump( " STOP");
                                if (aStateFlags & WPL.STATE_IS_REQUEST)
                                    dump( " REQ");
                                if (aStateFlags & WPL.STATE_IS_DOCUMENT)
                                    dump( " DOC");
                                if (aStateFlags & WPL.STATE_IS_NETWORK)
                                    dump( " NET");
                                if (aStateFlags & WPL.STATE_IS_WINDOW)
                                    dump( " WIN");
                                dump("\n")*/
                                return;
                            }

                            if (this._firstBlankLoad)
                                return;

                            // aStateFlags:
                            // STATE_START, STATE_REDIRECTING, STATE_TRANSFERRING, STATE_NEGOTIATING, STATE_STOP
                            // STATE_IS_REQUEST, STATE_IS_DOCUMENT, STATE_IS_NETWORK, STATE_IS_WINDOW

                            /*dump("onStateChange URI:"+uri);
                            if (aStateFlags & WPL.STATE_START)
                                dump( " START");
                            if (aStateFlags & WPL.STATE_TRANSFERRING)
                                dump( " TRANS");
                            if (aStateFlags & WPL.STATE_NEGOTIATING)
                                dump( " NEGO");
                            if (aStateFlags & WPL.STATE_STOP)
                                dump( " STOP");
                            if (aStateFlags & WPL.STATE_IS_REQUEST)
                                dump( " REQ");
                            if (aStateFlags & WPL.STATE_IS_DOCUMENT)
                                dump( " DOC");
                            if (aStateFlags & WPL.STATE_IS_NETWORK)
                                dump( " NET");
                            if (aStateFlags & WPL.STATE_IS_WINDOW)
                                dump( " WIN");*/

                            if (!this._mainPageLoading) {
                                //dump("\n")
                                if ( (aStateFlags & WPL.STATE_START) && (aStateFlags & WPL.STATE_IS_WINDOW)) {
                                    this._mainPageLoading = uri;

                                    // phantomjs call onInitialized twice.. don't know why.
                                    // let's imitate it
                                    if (nav.webPage.onInitialized)
                                        nav.webPage.onInitialized();

                                    if (nav.webPage.onLoadStarted)
                                        nav.webPage.onLoadStarted();
                                }
                                return;
                            }

                            // ignore all request that are not the main request
                            if (this._mainPageLoading != uri) {
                                //dump(" IGNORED\n");
                                return;
                            }
                            //dump("\n")

                            if ( (aStateFlags & WPL.STATE_STOP) && (aStateFlags & WPL.STATE_IS_REQUEST)) {
                                if (nav.webPage.onInitialized)
                                    nav.webPage.onInitialized();
                            }
                        },

                        onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage){},
                        onSecurityChange : function(aWebProgress, aRequest, aState) { },
                        onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI){},

                        debug : function(aWebProgress, aRequest) {
                            //aWebProgress -> browser
                            //aWebProgress.DOMWindow
                            //aWebProgress.isLoadingDocument
                            //arequest  cancel(), resume(), suspend(), isPending()
                        },
                        onProgressChange : function (aWebProgress, aRequest,
                                aCurSelfProgress, aMaxSelfProgress,
                                aCurTotalProgress, aMaxTotalProgress)
                        {},
                        onProgressChange64 : function (aWebProgress, aRequest,
                                aCurSelfProgress, aMaxSelfProgress,
                                aCurTotalProgress, aMaxTotalProgress)
                        {}

                    }
                    this.browser.addProgressListener(this.mProgressListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
                ]]>
                </body>
            </method>

            <method name="evaluate">
                <parameter name="script" />
                <parameter name="args" />
                <body><![CDATA[
                // FIXME: should the sandbox be created each time or only after the page is loaded?
                let sandbox = Components.utils.Sandbox(this.browser.contentWindow,
                            {
                                'sandboxName': this.browser.currentURI.spec,
                                'sandboxPrototype': this.browser.contentWindow,
                                'wantXrays': true
                            });
                sandbox.__slimer_args = Array.isArray(args)?args:[args];
                script = '('+script.toSource()+').apply(null, __slimer_args);';
                return Components.utils.evalInSandbox(script, sandbox);
                ]]></body>
            </method>

            <method name="evaluateAsync">
                <parameter name="script" />
                <body><![CDATA[
                // FIXME: should the sandbox be created each time or only after the page is loaded?
                let sandbox = Components.utils.Sandbox(this.browser.contentWindow,
                            {
                                'sandboxName': this.browser.currentURI.spec,
                                'sandboxPrototype': this.browser.contentWindow,
                                'wantXrays': true
                            });
                script = '('+script.toSource()+')();';
                window.setTimeout(function() {
                    Components.utils.evalInSandbox(script, sandbox);
                }, 0)
                ]]></body>
            </method>
            <method name="includeJS">
                <parameter name="url" />
                <parameter name="callback" />
                <body>
                    let doc = this.browser.contentWindow.document;
                    let body = doc.documentElement.getElementsByTagName("body")[0];
                    let script = doc.createElement('script');
                    script.setAttribute('type', 'text/javascript');
                    script.setAttribute('src', url);
                    let listener = function(event){
                        script.removeEventListener('load', listener, true);
                        callback();
                    }
                    script.addEventListener('load', listener, true);
                    body.appendChild(script);
                </body>
            </method>
            <method name="injectJS">
                <parameter name="source" />
                <body>
                    let doc = this.browser.contentWindow.document;
                    let body = doc.documentElement.getElementsByTagName("body")[0];
                    let script = doc.createElement('script');
                    script.setAttribute('type', 'text/javascript');
                    script.textContent = source;
                    body.appendChild(script);
                </body>
            </method>
        </implementation>
        <handlers>
        </handlers>
    </binding>
</bindings>


